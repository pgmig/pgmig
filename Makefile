## pgmig Makefile:
## Postgresql "drop/create" migrations
#:

SHELL          = /bin/sh
CFG           ?= .env
PRG           ?= $(shell basename $$PWD)
PKGS          ?= pgmig

# -----------------------------------------------------------------------------
# Build config

GO            ?= go
SOURCES        = $(shell find . -maxdepth 3 -mindepth 1 -name '*.go'  -printf '%p\n')
APP_VERSION   ?= $(shell git describe --tags --always)
GOLANG_VERSION = 1.15.5-alpine3.12

OS            ?= linux
ARCH          ?= amd64
ALLARCH       ?= "linux/amd64 linux/386 darwin/386 windows/amd64"
DIRDIST       ?= dist

# Path to golang package docs
GODOC_REPO    ?= github.com/$(PRG)/$(PRG)
# Path to docker image registry
DOCKER_IMAGE  ?= ghcr.io/$(PRG)/$(PRG)

# -----------------------------------------------------------------------------
# Docker image config

# Hardcoded in docker-compose.yml service name
DC_SERVICE    ?= app

# docker/compose version
DC_VER        ?= latest

# docker app for change inside containers
DOCKER_BIN    ?= docker

# -----------------------------------------------------------------------------
# Runtime data

# DB name
PGDATABASE    ?= $(PRG)_test
# DB user who owns created objects
PGUSER        ?= $(PRG)_adm
# DB user password
PGPASSWORD    ?= pgmigtestingpass
# DB role for tests run (if given)
PGMIG_TEST_ROLE ?=

# DB host
PGHOST        ?= localhost
# DB port
PGPORT        ?= 35432
# connect via SSL
PGSSLMODE     ?= disable
# Client name inside database
PGAPPNAME     ?= $(PRG)

define CONFIG_DEFAULT
# ------------------------------------------------------------------------------
# pgmig config file, generated by make $(CFG)

# Database

# DB host
PGHOST=$(PGHOST)
# DB port
PGPORT=$(PGPORT)
# DB name
PGDATABASE=$(PGDATABASE)
# DB user who owns created objects
PGUSER=$(PGUSER)
# DB user password
PGPASSWORD=$(PGPASSWORD)
# DB role for tests run (if given)
PGMIG_TEST_ROLE=$(PGMIG_TEST_ROLE)

# Client name inside database
PGAPPNAME=$(PGAPPNAME)
# connect via SSL
PGSSLMODE=$(PGSSLMODE)

# Postgresql container network
PG_NETWORK=$(PG_NETWORK)

endef
export CONFIG_DEFAULT

-include $(CFG)
export

#.EXPORT_ALL_VARIABLES:

# -----------------------------------------------------------------------------

.PHONY: all gen doc build-standalone coverage cov-html build test lint fmt vet vendor up down build-docker clean-docker

# default: show target list
all: help

# ------------------------------------------------------------------------------
## Compile operations
#:

## Generate mocks
gen:
	$(GO) generate ./...

## Format go sources
fmt:
	$(GO) fmt ./...

## Run vet
vet:
	$(GO) vet ./...

## run linters
lint:
	golint ./...
	golangci-lint run ./...

## Run tests and fill coverage.out
test: clean coverage.out

# internal target
coverage.out: $(SOURCES)
	$(GO) test -tags test -race -covermode=atomic -coverprofile=$@ ./...

## run tests that use services from docker-compose.yml
test-docker: up-pg test-d down-pg

test-d: export TEST_DSN_PG=postgres://
test-d: clean coverage.out

#pgmig:secret@localhost:$(TEST_PG_PORT)/pgmig_test?sslmode=disable

up-pg: CMD=up -d pg
up-pg: dc

down-pg:
	@$(MAKE) -s down

## Open coverage report in browser
cov-html: coverage.out
	$(GO) tool cover -html=coverage.out

## Build app
build: $(PRG)

$(PRG): $(SOURCES)
	GOOS=$(OS) GOARCH=$(ARCH) $(GO) build -v -o $@ -ldflags \
	  "-X main.version=$(APP_VERSION)" ./cmd/$@

## Build app used in docker from scratch
build-standalone: vet lint test
	GOOS=linux CGO_ENABLED=0 $(GO) build -a -v -o $(PRG) -ldflags \
	  "-X main.version=$(APP_VERSION)" ./cmd/$(PRG)

## run from sources
run:
	$(GO) run ./cmd/$(PRG) --debug init $(PKGS)

run-%:
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	$(GO) run -ldflags "-X main.version=$(APP_VERSION)" ./cmd/$(PRG)/ $$opts $* $(PKGS)

vrun-%:
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	$(GO) run ./cmd/$(PRG)/ $$opts --debug $* $(PKGS)

cmd-%: build
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	./$(PRG) $$opts $* $(PKGS)

vcmd-%: build
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	./$(PRG) $$opts --verbose $* $(PKGS)

run-list-%:
	@$(GO) run ./cmd/$(PRG)/ --verbose --mig.listonly $* $(PKGS)

# ------------------------------------------------------------------------------
## build app for all platforms
buildall:
	@echo "*** $@ ***"
	@[ -d .git ] && GH=`git describe --tags` || GH=nogit ; \
for a in "$(ALLARCH)" ; do \
  echo "** $${a%/*} $${a#*/}" ; \
  P=$(PRG)-$${a%/*}_$${a#*/} ; \
  [ "$${a%/*}" == "windows" ] && P=$$P.exe ; \
  GOOS=$${a%/*} GOARCH=$${a#*/} go build -o $$P -ldflags \
  "-X main.version=$$GH" ./cmd/$(PRG) ; \
done

## create disro files
dist: clean buildall
	@echo "*** $@ ***"
	@[ -d .git ] && GH=`git describe --tags` || GH=nogit ; \
	[ -d $(DIRDIST) ] || mkdir $(DIRDIST) ; \
sha256sum $(PRG)* > $(DIRDIST)/SHA256SUMS ; \
for a in "$(ALLARCH)" ; do \
  echo "** $${a%/*} $${a#*/}" ; \
  P=$(PRG)-$${a%/*}_$${a#*/} ; \
  [ "$${a%/*}" == "windows" ] && P1=$$P.exe || P1=$$P ; \
  zip "$(DIRDIST)/$$P-$$GH.zip" "$$P1" README.md ; \
done

## clean generated files
clean:
	@echo "*** $@ ***" ; \
	  for a in "$(ALLARCH)" ; do \
	    P=$(PRG)_$${a%/*}_$${a#*/} ; \
	    [ ! -f $$P ] || rm $$P ; \
	  done
	@[ ! -f $$P.exe ] || rm $$P.exe
	@[ ! -d $(DIRDIST) ] || rm -rf $(DIRDIST)
	@[ ! -f $(PRG) ] || rm -f $(PRG)
	@[ ! -f coverage.out ] || rm coverage.out

# ------------------------------------------------------------------------------
## Docker operations
#:

## start service in container
up:
up: CMD=up -d $(DC_SERVICE)
up: dc

## stop service
down:
down: CMD=rm -f -s
down: dc

## build docker image
docker-build: CMD="build --force-rm $(DC_SERVICE)"
docker-build: dc

## remove docker image & temp files
docker-clean:
	[ "$$($(DOCKER_BIN) images -q $(DC_IMAGE) 2> /dev/null)" = "" ] || $(DOCKER_BIN) rmi $(DC_IMAGE)


# ------------------------------------------------------------------------------

# $$PWD usage allows host directory mounts in child containers
# Thish works if path is the same for host, docker, docker-compose and child container
## run $(CMD) via docker-compose
dc: docker-compose.yml
	@$(DOCKER_BIN) run --rm  -i \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v $$PWD:$$PWD -w $$PWD \
  --env=DOCKER_IMAGE=$(DOCKER_IMAGE) \
  --env=GOLANG_VERSION=$(GOLANG_VERSION) \
  --env=PGPORT=$(PGPORT) --env=PGDATABASE=$(PGDATABASE) \
  --env=PGUSER=$(PGUSER) --env=PGPASSWORD=$(PGPASSWORD) \
  docker/compose:$(DC_VER) \
  -p $(PRG) $(CMD)

# ------------------------------------------------------------------------------
## Database via docker

# (internal) Wait for postgresql container start
docker-wait:
	@echo -n "Checking PG is ready..."
	@until [[ `docker inspect -f "{{.State.Health.Status}}" $$PG_CONTAINER` == healthy ]] ; do sleep 1 ; echo -n "." ; done
	@echo "Ok"

## Create user, db and load dump
db-create: docker-wait
	@echo "*** $@ ***" ; \
	sql="CREATE USER \"$$PGUSER\" WITH PASSWORD '$$PGPASSWORD'" ; \
	if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then sql="$$sql IN ROLE \"$$PGMIG_TEST_ROLE\"" ; fi ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "$$sql" 2> >(grep -v "already exists" >&2) || true ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "CREATE DATABASE \"$$PGDATABASE\" OWNER \"$$PGUSER\";" 2> >(grep -v "already exists" >&2) || db_exists=1 ; \

## Drop database and user
db-drop: docker-wait
	@echo "*** $@ ***"
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP DATABASE \"$$PGDATABASE\";" || true
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP USER \"$$PGUSER\";" || true

psql: docker-wait ## Run psql
	@docker exec -it $$PG_CONTAINER psql -U $$PGUSER -d $$PGDATABASE

## Run local psql
psql-local:
	@psql

# ------------------------------------------------------------------------------
## Other
#:

## Count lines of code (including tests) and update LOC.md
cloc: LOC.md

LOC.md: $(SOURCES)
	cloc --by-file --not-match-f='(_moq_test.go|ml|.md|.sh|.json|file)$$' --md . > $@ 2>/dev/null
	cloc --by-file --not-match-f='(_test.go|ml|.md|.sh|.json|file)$$' . 2>/dev/null
	cloc --by-file --not-match-f='_moq_test.go$$' --match-f='_test.go$$' .  2>/dev/null

# create initial config
$(CFG):
	@[ -f $@ ] || { echo "Creating default $@" ; echo "$$CONFIG_DEFAULT" > $@ ; }

## Create default config file
config:
	@true

## update docs at pkg.go.dev
godoc:
	vf=$(APP_VERSION) ; v=$${vf%%-*} ; echo "Update for $$v..." ; \
	curl 'https://proxy.golang.org/$(GODOC_REPO)/@v/'$$v'.info'

## update latest docker image tag at ghcr.io
ghcr:
	vf=$(APP_VERSION) ; vs=$${vf%%-*} ; v=$${vs#v} ; echo "Update for $$v..." ; \
	docker pull $(DOCKER_IMAGE):$$v && \
	docker tag $(DOCKER_IMAGE):$$v $(DOCKER_IMAGE):latest && \
	docker push $(DOCKER_IMAGE):latest


# This code handles group header and target comment with one or two lines only
## list Makefile targets
## (this is default target)
help:
	@grep -A 1 -h "^## " $(MAKEFILE_LIST) \
  | sed -E 's/^--$$// ; /./{H;$$!d} ; x ; s/^\n## ([^\n]+)\n(## (.+)\n)*(.+):(.*)$$/"    " "\4" "\1" "\3"/' \
  | sed -E 's/^"    " "#" "(.+)" "(.*)"$$/"" "" "" ""\n"\1 \2" "" "" ""/' \
  | xargs printf "%s\033[36m%-15s\033[0m %s %s\n"
