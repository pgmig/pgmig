
SHELL          = /bin/bash
CFG            = .env

PRG           ?= $(shell basename $$PWD)

PKGS          ?= pgmig

# -----------------------------------------------------------------------------
# Build config

GO            ?= go
VERSION       ?= $(shell git describe --tags)
SOURCES       ?= cmd/*/*.go *.go

OS            ?= linux
ARCH          ?= amd64
STAMP         ?= $$(date +%Y-%m-%d_%H:%M.%S)
ALLARCH       ?= "linux/amd64 linux/386 darwin/386 windows/amd64"
DIRDIST       ?= dist

# -----------------------------------------------------------------------------
# Docker image config

# application name, docker-compose prefix
PROJECT_NAME  ?= $(PRG)

# Hardcoded in docker-compose.yml service name
DC_SERVICE    ?= app

# Generated docker image
DC_IMAGE      ?= $(PRG)

# docker/compose version
DC_VER        ?= 1.23.2

# golang image version
GO_VER        ?= 1.12.6

# docker app for change inside containers
DOCKER_BIN    ?= docker

# Postgresql container name
PG_CONTAINER  ?= dcape_db_1
# Postgresql container network
PG_NETWORK    ?= dcape_net

# -----------------------------------------------------------------------------
# Runtime data

# DB name
PGDATABASE    ?= $(PRG)
# DB user who owns created objects
PGUSER        ?= $(PRG)_adm
# DB user password
PGPASSWORD    ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)
# DB role for tests run (if given)
PGMIG_TEST_ROLE ?=

# DB host
PGHOST        ?= localhost
# DB port
PGPORT        ?= 5432
# connect via SSL
PGSSLMODE     ?= disable
# Client name inside database
PGAPPNAME     ?= $(PRG)

define CONFIG_DEFAULT
# ------------------------------------------------------------------------------
# pgmig config file, generated by make $(CFG)

# Database

# DB host
PGHOST=$(PGHOST)
# DB port
PGPORT=$(PGPORT)
# DB name
PGDATABASE=$(PGDATABASE)
# DB user who owns created objects
PGUSER=$(PGUSER)
# DB user password
PGPASSWORD=$(PGPASSWORD)
# DB role for tests run (if given)
PGMIG_TEST_ROLE=$(PGMIG_TEST_ROLE)

# Client name inside database
PGAPPNAME=$(PGAPPNAME)
# connect via SSL
PGSSLMODE=$(PGSSLMODE)

# Postgresql container network
PG_NETWORK=$(PG_NETWORK)

endef
export CONFIG_DEFAULT

-include $(CFG)
export

#.EXPORT_ALL_VARIABLES:

# -----------------------------------------------------------------------------

.PHONY: all gen doc build-standalone coverage cov-html build test lint fmt vet vendor up down build-docker clean-docker

##
## Available make targets
##

# default: show target list
all: help

# ------------------------------------------------------------------------------
## Sources

## Run from sources
run:
	$(GO) run ./cmd/$(PRG)/ init $(PKGS)

run-%:
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	$(GO) run -ldflags "-X main.version=$(VERSION)" ./cmd/$(PRG)/ $$opts $* $(PKGS)

vrun-%:
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	$(GO) run ./cmd/$(PRG)/ $$opts --verbose $* $(PKGS)

cmd-%: build
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	./$(PRG) $$opts $* $(PKGS)

vcmd-%: build
	@if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then opts="--mig.var=test_role:$(PGMIG_TEST_ROLE)" ; else opts="" ; fi ; \
	./$(PRG) $$opts --verbose $* $(PKGS)

#	$(GO) run ./cmd/$(PRG)/ --verbose --mig.var=test_role:$(PGMIG_TEST_ROLE) $* $(PKGS)

run-list-%:
	@$(GO) run ./cmd/$(PRG)/ --verbose --mig.listonly $* $(PKGS)

## Build app with checks
build-all: lint lint-more vet cov build

## Build app
build: gen
	go build -ldflags "-X main.version=$(VERSION)" ./cmd/$(PRG)

## Build app used in docker from scratch
build-standalone: cov vet lint lint-more
	CGO_ENABLED=0 GOOS=linux go build -ldflags "-X main.version=`git describe --tags`" -installsuffix 'static' -a ./cmd/$(PRG)

## Generate mocks
gen:
	$(GO) generate ./...

## Format go sources
fmt:
	$(GO) fmt ./...

## Run vet
vet:
	$(GO) vet ./...

## Run linter
lint:
	golint ./...

## Run more linters
lint-more:
	golangci-lint run ./...

## Run tests and fill coverage.out
cov: coverage.out

# internal target
coverage.out: $(SOURCES)
	$(GO) test -test.v -test.race -coverprofile=$@ -covermode=atomic -tags test ./...

## Open coverage report in browser
cov-html: cov
	$(GO) tool cover -html=coverage.out

## Clean coverage report
cov-clean:
	rm -f coverage.*

# ------------------------------------------------------------------------------
## build app for all platforms
buildall:
	@echo "*** $@ ***"
	@[ -d .git ] && GH=`git describe --tags` || GH=nogit ; \
for a in "$(ALLARCH)" ; do \
  echo "** $${a%/*} $${a#*/}" ; \
  P=$(PRG)_$${a%/*}_$${a#*/} ; \
  [ "$${a%/*}" == "windows" ] && P=$$P.exe ; \
  GOOS=$${a%/*} GOARCH=$${a#*/} go build -o $$P -ldflags \
  "-X main.version=$$GH" ./cmd/$(PRG) ; \
done

## create disro files
dist: clean buildall
	@echo "*** $@ ***"
	@[ -d .git ] && GH=`git describe --tags` || GH=nogit ; \
	[ -d $(DIRDIST) ] || mkdir $(DIRDIST) ; \
sha256sum $(PRG)* > $(DIRDIST)/SHA256SUMS ; \
for a in "$(ALLARCH)" ; do \
  echo "** $${a%/*} $${a#*/}" ; \
  P=$(PRG)_$${a%/*}_$${a#*/} ; \
  [ "$${a%/*}" == "windows" ] && P1=$$P.exe || P1=$$P ; \
  zip "$(DIRDIST)/$$P-$$GH.zip" "$$P1" README.md ; \
done

## clean generated distrib files
clean:
	@echo "*** $@ ***" ; \
	  for a in "$(ALLARCH)" ; do \
	    P=$(PRG)_$${a%/*}_$${a#*/} ; \
	    [ -f $$P ] && rm $$P || true ; \
	  done
	@[ -f $$P.exe ] && rm $$P.exe || true ; \
	@[ -d $(DIRDIST) ] && rm -rf $(DIRDIST) || true
	@[ -f $(PRG) ] && rm -f $(PRG) || true

# ------------------------------------------------------------------------------
# DB operations with docker and [dcape](https://github.com/dopos/dcape)

# (internal) Wait for postgresql container start
docker-wait:
	@echo -n "Checking PG is ready..."
	@until [[ `docker inspect -f "{{.State.Health.Status}}" $$PG_CONTAINER` == healthy ]] ; do sleep 1 ; echo -n "." ; done
	@echo "Ok"

## Create user, db and load dump
db-create: docker-wait
	@echo "*** $@ ***" ; \
	sql="CREATE USER \"$$PGUSER\" WITH PASSWORD '$$PGPASSWORD'" ; \
	if [ -n "$$PGMIG_TEST_ROLE" ] && [[ "$$PGMIG_TEST_ROLE" != "$$PGUSER" ]] ; then sql="$$sql IN ROLE \"$$PGMIG_TEST_ROLE\"" ; fi ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "$$sql" 2> >(grep -v "already exists" >&2) || true ; \
	docker exec -i $$PG_CONTAINER psql -U postgres -c "CREATE DATABASE \"$$PGDATABASE\" OWNER \"$$PGUSER\";" 2> >(grep -v "already exists" >&2) || db_exists=1 ; \

## Drop database and user
db-drop: docker-wait
	@echo "*** $@ ***"
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP DATABASE \"$$PGDATABASE\";" || true
	@docker exec -it $$PG_CONTAINER psql -U postgres -c "DROP USER \"$$PGUSER\";" || true

psql: docker-wait ## Run psql
	@docker exec -it $$PG_CONTAINER psql -U $$PGUSER -d $$PGDATABASE

## Run local psql
psql-local:
	@psql

# ------------------------------------------------------------------------------
## Misc

## Count lines of code (including tests) and update LOC.md
cloc: LOC.md

LOC.md: $(SOURCES)
	cloc --by-file --not-match-f='(_moq_test.go|ml|.md|.sh|.json|file)$$' --md . > $@ 2>/dev/null
	cloc --by-file --not-match-f='(_test.go|ml|.md|.sh|.json|file)$$' . 2>/dev/null
	cloc --by-file --not-match-f='_moq_test.go$$' --match-f='_test.go$$' .  2>/dev/null

# create initial config
$(CFG):
	@[ -f $@ ] || { echo "Creating default $@" ; echo "$$CONFIG_DEFAULT" > $@ ; }

## Create default config file
config:
	@true

## List Makefile targets
help:  Makefile
	@grep -A1 "^##" $< | grep -vE '^--$$' | sed -E '/^##/{N;s/^## (.+)\n(.+):(.*)/\t\2:\1/}' | column -t -s ':'
